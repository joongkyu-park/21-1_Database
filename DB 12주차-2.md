# DB 12주차-2

12장. Physical Storage Systems

2)
목표
-하드(마그네틱 디스크)나 ssd와 같은 기본적인 저장장치들의 특성알기
-다수의 저장장치를 사용해서 신뢰성있는 storage구조를 구축하는 방법 -> 레이드(RAID) 라고 말한다.

3) 
아웃라인

4)
피지컬 스토리지 미디어

5)
저장장치는 
volatile과 non-volatile로 나뉜다.
휘발성 : 전원이 꺼지면 내용이 삭제되는것
-> 고가의 연산능력이 높은
비휘발성 : 전원이 꺼져도 내용이 저장되어있는 것.
-> 저가이면서 저장공간이 큰

휘발성 저장장치 대표 -> RAM
비휘발성 저장장치의 대표 ->하드디스크나 SSD

저장장치의 종류는 여러가지가 있고, 분류하는 기준은 다음과 같다
-데이터에 접근하는 속도
-저장장치의 비용(데이터 단위당) 예를들어 램1MB의 가격이랑 하드1MB의 가격이 다르니까
-데이터 저장의 신뢰성

6)
storage hierarchy

화살표 올라가는 것 : 속도가 빠를수록, 비용이 클수록
화살표 내려가는 것 : 속도가 느릴수록, 비용이 작을수록

캐시메모리와 메인메모리는 휘발성

CPU와 하드 사이에 메모리같은 중간 저장장치를 두는 이유는?
CPU와 하드디스크의 속도는 차이가 엄청 크다.
따라서 속도차이를 극복하기 위하여 이런 식으로 계층화 시킨다.

7)
primary storage
저장 장치중 가장 빠르고 volatile이다. 가격도 비싸다.
캐시, 메인메모리(RAM)
RAM위에 있는 프로세스들을 CPU가 처리하는데
RAM에서 자주 쓰이는것을 캐시메모리에 올려서 더 빠르게 처리.

secondary storage
일반적인 저장장치들. non-volatile.
다른말로 on-line storage라고 부름
flash 메모리, 마그네틱 디스크 등

tertiary storage
씨디, 유에스비, 외장하드 같은 하드나 ssd이외의 저장장치들을 말함.
속도가 더 느림.
off-line storage라고 부름

8)
Storage Interfaces

9)
Storage Interfaces
하드나 ssd, usb 등을 컴퓨터와 어떻게 연결하는가.

SATA 케이블이 대표적인 Storage Interfaces이다.

최근에는 비휘발성 메모리를 좀더 빠르게 연결하기위해 NVMe라는 인터페이스를 사용한다.

자세하게 다루진 않겠다.

특정한 경우 컴퓨터와 직접연결하지않고 네트워크와 연결하는 경우가있다.

SAN : 고속네트워크를 이용해 다수의 디스크가 서버에 연결되는경우
NAS : SAN과 같은데 조금더 개선한 방식. 다수의 디스크를 연결하는데, 하나의 대용량 디스크처럼 쓰는게 아니라 파일시스템프로콜을 이용하여 그것을 파일시스템의 인터페이스로 사용하는 방식.
-> 두 개의 차이는 파일시스템프로토콜을 사용하느냐 안하느냐 차이

이 부분은 중요하지 않음. 디스크와 컴퓨터 시스템을 연결하는 방법이다 정도만생각. 

10)
마그네틱 디스크(하드)

11)
하드디스크의 구성

12)
read-write 헤드를 통해 정보의 읽기와 쓰기가 가능하다.
어떻게 읽기-쓰기를 하냐
sector라는 공간에 데이터가 저장되어있고, 헤드가 접근하여 read-write 진행

플래터.
디스크를 이루는 가장 큰 단위. cd와 같은 원판 모양.

플래터내에 track이라는게 존재.
트랙은 플래터마다 약 5만개~10만개가 존재. 트랙 내에 존재하는 각각의 요소를 sector라고 한다. 사실상 섹터가 중요하다
sector : 디스크로 부터 데이터를 읽고 쓸 수있는 정보의 가장 작은 단위

트랙은 이너트랙 아우터트랙으로 나뉜다.
이너트랙 : 500~1000 섹터 존재
아우터트랙 : 1000~2000 섹터 존재

disk arm에 의해서 트랙의 위치를 계속 찾는다.
적합한 트랙과 섹터를 찾게되면 read-write가 이루어진다.

head-disk assemblies
플래터와 헤드의 조합.
스핀들 위에 있는 다수의 트랙들. 보통 1~5개의 트랙들과 플래터의 매칭되는 각각의 헤드들을 합쳐서 head-disk assemblies라고 한다.

실린더
모든 플래터의 i번째 트랙을 i번째 실린더라고한다.
왜 이렇게 말하냐.
모든 플래터는 동일하게 회전이 되기때문에, 동일한 위치를 관리를 할 필요가 있고, 특정 헤드가 i번째에 위치해있으면 다른 헤드들도 …
동일한 위치에 있는걸 실린더라고 한다.

13)
디스크 컨트롤러
일종의 인터페이스. 컴퓨터시스템과 디스크드라이버 하드웨어를 연결해주는 인터페이스

디스크 컨트롤러에는 섹터를 읽고 쓰기위한 명령어가 있다

디스크 암을 적합한 트랙과 섹터에 위치 시켜서 데이터를 리드-라이트 한다.

checksum을 통해서 데이터를 제대로 읽어올수있는지 없는지 확인.
만약 데이터가 손상이 되어있다면, checksum을 통해서 확인할 수 있다.

remapping of bad sectors
문제가 있는 섹터정보를 다른곳에 재배치하는 작업.
예를들어 섹터가 손상이 된곳을 컨트롤러가 발견하여 섹터를 다른 위치에 저장하므로써 데이터의 손상을 막아주는 작업을 하게된다.

14)
디스크의 성능을 측정하는 방안.

디스크의 성능은 저장용량, 데이터 access time 등으로 측정

access time
seek time과 rotational latency를 합친값
리드-라이트 요청부터 요청된 데이터를 전송하기 전까지를 access time이라고 한다.

seek time
arm이 적절한 트랙에 위치하는데 걸리는 시간.
보통 4~10밀리세컨드.

헤드가 적합한 트랙에 위치 된 다음에,
적절한 sector에 access 될 때 까지 걸리는 시간을
Rotational latency라고 한다.
보통 4~11밀리세컨드

즉,
암을 적절한 트랙에 위치 -> 식 타임
트랙이 돌아서 적합한 섹터 찾기 -> 로테이셔널 레이턴시

이 두개를 합쳐서 access time을 측정.

15)
data-transfer rate
데이터가 전송되는 속도.
한번에 데이터가 얼마나 전송될 수 있냐.
데이터가 디스크로부터 검색되거나 저장될 수 있는 비율.

mean time to failure(MTTF)
access time이나 데이터전송 속도에따라
디스크의 퍼포먼스를 측정한다고 했는데,
이건 신뢰성을 측정하는 것.

디스크가 고장날 때 까지 걸리는 시간.

보통 5만~12만 시간. 57년~136년.
-> 사실상 영구적으로 저장가능.

그러나 소모품이기때문에 MTTF가 디스크를 쓰면쓸수록 떨어진다.
그래서 5년에 한번정도 하드디스크를 갈아주면 좋다.

16)
플래시 메모리(SSD)

17)
Flash Storage

NAND flash와 NOR flash가 있다.
NAND flash는 NOR flash보다 싸고 저장용량이 크기 떄문에 더 대중적으로 이용됨.
페이지라고 하는 단위를 통해(보통 512바이트 ~ 4키로바이트) 이루어진다.
페이지를 리드하는데 20~100마이크로세컨드가 걸린다.
순차read와 random read의 시간 차이가 거의 없다.
단점은 덮어쓰기가 안되기때문에 지우고 다시 write해야함. (하드는 덮어쓰기가 가능)
NAND flash의 대표적인게 SSD

자세한 설명은 사실 컴퓨터구조를 듣자

18)
write를 할 때 지우는 작업이 필요하다.
지우기를 할 때 필요로 하는게 erase block이라는 단위를 통해 지우기 수행.
보통 2~5밀리세컨드 걸림.
erase block은 보통 256KB ~ 1MB의 크기

ssd와 같은 경우는 지우는 횟수가 제한되어있다.
제한된 지움횟수가 넘어섰을 떄는 SSD의 성능이 많이 떨어지고 신뢰성이 떨어진다.
그 지움횟수는 10만번~100만번
그 횟수를 넘어가면 SSD의 성능자체가 떨어진다
->이걸 방지하고자하는게 wear leveling
지우고자하는 것을들 좀 고르게 하여 ssd를 오래 쓰게하는것

ssd는 빠르지만 하드에 비해 저장용량이 작고 신뢰성 기간이 좀 짧다라는 단점이 아직있다.

19)
SSD의 성능 측정 metrics

ssd와 같은 경우는 기본적으로 하드보다 read-write 성능이 뛰어나다정도만.
IOPS(input output per second)

하이브리드 디스크
플래시의 개념과 하드디스크의 개념을 혼합.
하이브리드 -> 각자의 장단점을 상호보완해주는.

20)
RAID
데이터를 중복해서 저장하거나 병렬처리를 통해 저장해서 데이터의 신뢰성을 높이는 방법.
디스크가 고장나면 데이터가 지워지고 많은 문제가 발생하는데 그것들을 방지하기 위한 방안

21)
RAID(Redundatn Arrays of Independent Disks) : 독립적인 디스크를 여러개 중복해서 사용한다
다수의 디스크를 병렬적으로 사용하면서 capacitiy나 속도를 올리고,
데이터를 중복해서 저장하므로써 신뢰성을 올린다.
하나의 디스크가 고장나더라도 다른 곳에 저장되있으므로 복구하는데 도움된다.

2가지를 기준으로 설명
병렬적으로 데이터를 처리할거냐, 혹은 디스크를 여러가지에 중복할거냐

22)
Redundancy를 통해 신뢰성을 올리기
데이터를 복사해서 저장한다.
디스크가 고장이 났을 경우 정보의 손실을 막기 위해서 추가적인 정보를 저장하는 것

가장 쉬운 Redundancy -> Mirroring
모든 디스크를 복사.
하나의 로지컬 디스크는 2개의 피지컬 디스크로 구성된다. 원본 디스크와 복사 디스크.
write는 2개다 하고, read는 둘중에 하나에만 접근
하나가 고장나면 다른 디스크에 데이터 저장되어있기때문에 문제발생X
만약 두개의 디스크가 fail나면 그때는 문제가 발생할 수있다. 정전이나면 문제가 발생할 수있다.

23)
두번째방안.
병렬처리를 하는 방식.

어쨌든 다수의 디스크에 분산해서 데이터를 저장하면, 데이터전송속도가 향상된다.

병렬처리는 데이터 처리속도를 높이기위해

2가지 분산처리방안
-Bit-level striping : 각 바이트를 비트로 쪼개 서 여러 디스크에 저장
single일 때보다 read는 8배가 빨라짐.
그러나 access time이 길어져 잘 사용하지 않음
-Block-level striping
n개의 디스크가 있다고했을때, 블록단위로 저장하여 비트단위보다 좀 더 효율적으로.
두가지장점.
블록에 대해서 병렬처리 가능 -> 동시에 여러 작업가능
블록의 크기가 크다면 모든 디스크를 활용하여 병렬적으로 처리하여 속도를 높일 수 있다.

병렬처리하는 이유.
-작은 데이터를 처리하면 병렬적으로 처리하면 속도가 더 빨라진다.
-블록의 크기가 크다면 다수의 디스크를 통해 처리를 하므로써  reponse time을 줄이는 효과를 볼 수가 있다.

정리)
redundancy : 신뢰성 높이기
병렬처리 : 속도 높이기

24)

RAID Level
parity bits를 이용해서 저비용의 redundancy와 병렬처리를 같이 사용

레이드 레벨 0
redundancy 없음. 그러나 블록은 분산처리는 함.
데이터를 손실해도 크리티컬하지않는 어플리케이션 등에서 사용.

레이드 레벨 1
분산처리를 하면서 동시에 redundancy도 함.
로그를 기록하는 그런 곳에 사용.

이번 챕터에서는 RAID 개념이 가장 중요하다.

