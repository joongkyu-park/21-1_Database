# DB 14주차-2

ch. 14 인덱싱(2)

2)
B+ tree 인덱스 구조
B tree 인덱스 구조
해싱

3)
아웃라인

4)
B+ tree 인덱스 구조 상에서 파일이 삽입, 삭제 등이 일어났을 때

5)
삽입과정

pr : 레코드를 가르키는 포인터
v : 레코드 상의 서치키 값

1. v가 삽입되어야하는 리프노드상의 공간을 찾아야한다.(삽입될 공간 찾기)
2. 리프노드에 찾으려는 서치키 존재
 	파일상의 레코드에만 업데이트
	포인터가 잘못되어있다면, 포인터도 수정
3. 인덱스 안에 서치키 값이 없을 경우
	파일에 레코드를 추가하는 작업
	리프노드상에 공간이 존재하면, v와 pr쌍을 해당 리프노드 상에 삽입
	공간이 없으면, 노드를 분리하여 리프노드를 재설정하여 v, pr을 추가가한다.
		-> 분리가 된다면 부모노드들도 업데이트 되겠자

6)
리프노드를 분리하는 경우에 대해 조금 더 포멀한 정의, 알고리즘
- 새로 들어오은 포인터, 서치키 값을 포함한 n개의 엔트리를 먼저 정렬시킨다
- n/2으로 나눠서 앞의 n/2은 앞에 노드에 넣고, 뒤 n/2은 노드를 새로 생성해서 값을 넣는다.
- 새로 생긴 노드에서 최소 서치키값을 k라고 할 때, k를 부모 노드에 넣어준다
- 부모노드도 꽉차있다면, 부모노드도 쪼개주고 부모의 부모노드에도 영향을 미치게 되는 구조.

따라서 다음과같이 리프노드를 분해해서 삽입한다. 이에 따라 부모노드도 설정이 바뀐다.

7)
예제 보면서 설명하자.
Adams라는 새로운 서치키가 삽입 될때

8)
다른 예제

9)
8의 예와 같이 리프노드가 아닐때의 분해
다음과 같은 과정
3가지로 분리하게 된다.
…

10)
삭제
파일상에서는 삭제되었다고 가정하고, B+ tree 인덱스상에서 삭제하는 과정

- 리프노드로 부터 삭제하게되는데,
- … 읽어보자 …

11)
예제를 통해
앞 노드에 공간이 있을경우

각각의 노드에 최소 엔트리 갯수를 만족시키게끔 해야한다.

12)
삭제되었을 때 왼쪽노드에 합칠 수 없는경우. 앞 노드가 꽉찼을 때
포인터를 재분배 시켜줘야한다.

각각의 노드에 최소 엔트리 갯수를 만족시키게끔

- 이 내용만 잘 상기하자
- 

- 

13)
예

14)
또 다른 예

15)
앞에서의 내용은 B+ Tree로 인덱싱하는 방법이었다

B+ Tree를 파일구조에 적용시킬 경우.
리프노드 자체가 레코드일 경우

장점
…

조심해야할점
원래는 리프노드상에 서치키값, 포인터만 들어가있었는데
여기서는 그게아니라 튜플의 정보, 레코드가 다 들어가니까 리프노드에 공간적인 이슈를 잘고려해야함

16)
B Tree 인덱스 파일

17)
B+ Tree랑 거의 똑같은데,
다른점은
B+ Tree : 서치키값의 중복 허용
리프노드에 특정 서치키값이 있을때, 부모에도 동일한 서치키값 온재가능

B Tree : 중복된 서치키 허용 안함

리프노드의 구조는 사실 B+ Tree와 똑같다
nonleaf 노드의 구조 : 자식 노드를 가르키는 포인터, 해당 서치키가 파일 레코드의 어디를 가르키냐에 대한 포인터, 2가지 포인터를 지닌다

18)
예시

19)
B+ Tree에 비해 장점
B+ Tree에는 특정값을 찾기위해 리프노드까지 내려갔어야함
B Tree는 리프노드가 아니어도 해당 파일 레코드 값을 찾을 수 있다
-> 장점 1개임. 그러나 그 경우가 매우 가끔 일어난ㄴ다

단점
굉장히 드문경우에만 논리프 노드에서 서치키값을 찾을 수 있다.
논리프 노드가 기존의 B+ Tree보다 훨씬 공간을 많이 차지 -> 성능적 이슈 존재
가장 큰 단점은 업데이트 시 B+ Tree보다 훨씬 더많은 부하를 요구
B+ Tree보다 구현도 훨씬 어려움

B+ Tree는 장점이 단점을 상쇄했는데,
B Tree는 단점이 많아서 잘 사용하지않는다

20)
해싱
자세하게는 안하고 간단하게만

21)
스태틱 해싱
고정된 공간 상에서 해시를 이용하여 파일 접근

버켓 : 1개이상의 레코드를 저장할 수 있는 공간 단위(디스크 상에서의 블락개념이라고도 볼 수 있다.)

서치키값을 해쉬함수에 넣어서 해당하는 버켓을 불러올 수 있다.

해쉬함수 h는 모든 서치키 k에 대해 버켓 B에 매칭이 된다.
-> h가 k와 B를 매핑시켜주는 작업을 한다.

하나의 버켓에 다수의 서치키 값이 들어갈 수 있다.
-> 원하는 서치키를 찾으려면 해당 버켓에 존재하는 모든 엔트리를 검사해야겠다.

해시 인덱스 : 서치키와 관련된 레코드를 가르키는 포인터를 저장하는 버켓으로 이루어져있다
해시 파일 오가니제이션 : 버켓내에 서치키에 해당하는 레코드가 바로 저장

22)
정적인 해싱과 같은경우 문제 발생가능
버켓에 서치키값을 분배해야하는데, 분배가 잘못될 수 있다.
그렇기 때문에 항상 해시함수는 균등하고 랜덤하게 서치키를 버켓에 할당시킬려고 노력
그러나 어쩔 수 없이 버켓오버플로우 발생가능
- 버켓의 개수가 부족할 뗴
- 특정 버켓에 서치키갑싱 몰리는 경우(분배가 잘못됨) -다수의 레코드가 동일한 서치키를 가질때 -해시함수가 키값을 균등하게 분배시키지 못하는 경우

23)
버켓 오버플로우를 방지하기위한 방안

오버플로우 체이닝
오버플로우가 발생한 버켓에 링크드리스트로 새로운 버켓을 연결
-> 클로즈드 해싱이라고 부른다

오픈 해싱 : 오버플로우 체이닝 자체를 인정하지 않음. 삭제하는 부분이 훨씬 어려워진다.
	-> 따라서 클로즈드 해싱이 더 많이 사용

24)
해싱을 통해서 파일을 어떻게 저장시키냐
간략한 예제
25)
예제 계속

->어느정도 골고루 분배되었지만 0과 7에는 아무 것도 없다.
3과 6에는 오버플로우가 곧 발생할 여지가 있다.

이 예제의 응용으로 시험문제가능성 ⭐️

26)
스태틱 해싱 단점

데이터베이스가 커지거나 작아지는 경우 적절히 대응 할 수 없다.
- 버켓의 개수가 너무 적은데 파일이 많아지면 버켓오버플로우 발생 -> 성능저하 발생
- 파일이 커질 것을 예상하고 버켓의 개수를 많이 만듬 -> 초기에 버킷공간 낭비

하나의 솔루션
주기적으로 새로운 해쉬함수를 적용하여 파일을 재구성
-> 그러나 비싼 방법이고 다른 연산에 영향을 미칠 수 있음

더 좋은 방법
버켓의 개수를 다이나믹하게 -> 다이나믹 해싱

스태틱에서는 버캣의 개수가 고정이었음

27)
다이나믹 해싱 해쉬함수도 동적으로 수정, 버켓 개수도 동적으로 수정

- 페리오딕 리해싱 주기적으로 해시테이블의 크기를 늘린다
- 리이너 해싱 해시의 크기를 선형적으로 증가시킴
- extendable 해싱 …(못들음)

28)
인덱싱 Vs 해싱

선택의 기준
- 주기적으로 재구성 할때 비용
- 업데이트가 얼마나 주기적으로 발생하는지, 잘대처가 가능한지
- 워스트케이스가 존재할 때 워스트케이스에 대해 비용이 많이 발생할텐데, 워스크 케이스는 고려하지않고 평균적인 어세스 타임만 최적화 시킬것인지

범위가 있는 쿼리 -> 인덱싱 주로 사용
키값에 기초한 쿼리 -> 해싱 주로 사용

실제 디비 시스템상에서는
기본적으로 해싱과 인덱싱을 두 개 제공하지만, B+ 트리를 대부분 사용.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

중간고사 봤던 방식과 동일하게 본다

중간고사에 비해 기말고사 내용이 어렵다. 열심히 해라
팁 : 응용을 낼수 있는 단원은 한정적 (6, 7단원)
중간 단원은 응용낼부분이 거의없다 (인덱싱의 B+트리정도는 할 수 있겠지만) 그거 제외 개념문제 -> 이런부분은 개념 착실히.
응용적인 부분은 책의 연습문제를 꼭 풀어볼것

