# DB 14주차-1

프로젝트 6/18 (금)까지 제출 보고서 : 10장분량으로 제한
-> iclass에 올릴것 

14장. Indexing
시험범위 마지막 단원. 다 다루진 않을 것

쿼리를 통해 파일내의 레코드를 불러오겠다.
쿼리를 보냈을 때, 원하는 튜플을 찾으려고 릴레이션 내에 모든 튜플을 찾아보는건은 비효율적이겠다 -> indexing 이용

2)
목표
- 데이터에 효율적으로 접근하는 다양한 방법들과 여러가지 인덱스 구조들
- B+ 인덱스 구조

3)
아웃라인

4)
인덱스의 기본적인 동작원리

5)
인덱스가 왜 필요한가
필요한 데이터에 빠르게 접근하기 위해.

서치 키 :인덱싱을 위해서 기준이 되는 것. 파일에서 레코드를 찾기위해 사용되는 어트리뷰트나 어트리뷰트의 집합. 그동안 배웠던 키 개념과 다름.

인덱스 파일(또는 인덱스 엔트리)는 다음과 같이 구성
서치키에 해당하는 파일의 값을 포인터로 가르키는 구조
![DB 14주차-1](images/DB%2014주차-1.png)

![DB 14주차-1-1](images/DB%2014주차-1-1.png)

인덱스파일은 원본파일보다 당연히 크기가 훨씬 작아야 겠다.

인덱스의 종류
- 오더드 인덱스 : 서치키가 정렬이 되어있는 경우
- 해쉬 인덱스 : 정렬이 따로 되어있지않고, 해시함수를 기반으로 버켓이라는 범위내에 일정하게 분배시키는 방식. 

6)
둘중에 어느것을 선택하면 좋을까
앞에서 배운 2가지 인덱스 기법 중 어떤것을 선택하면 좋은지에 대한 기준

- 어세스 타입 특정한 어트리뷰의 값을 갖는 레코드거나 특정한 범위에 들어가는 레코드 값을 찾는 등 여러가지 접근하는 데이터 타입을 고려 고려해야할 사안중 크게 중요한 사안은 아님
- 어세스 타임 가장 중요한 사안이라고 볼 수 있다. 특정 데이터를 찾는데 걸리는 시간.
- 데이터 삽입 시간 새로운 데이터가 삽입되는데 걸리는 시간 + 삽입될때 인덱스 구조가 변경되는시간
- 데이터 삭제 시간 데이터가 삭제되는데 걸리는 시간 + 삽입될때 인덱스 구조가 변경되는시간
- 스페이스 오버헤드 인덱스 구조가 있을 때, 인덱스 구조를 위한 부가적인 공간이 필요하겠다. 인덱스 값이 커질수록 스페이스 오버헤드가 증가하고, 어세스 타임이 짧아지겠다. 인덱스 구조의 공간과 데이터를 찾는 어세스 타임이 trade-off 관계이기 때문에 이를 고려할 필요가 있겠다.

7)
Ordered Indices

8)
Ordered Indices
인덱스 엔트리에서 서치키가 정렬되어 저장되어있음.
정렬된 서치키들은 포인터들을 가지고 있기때문에, 파일에서 해당 위치를 파악할 수 있다.

9)
크게 두가지 인덱스 존재

- 프라이머리 인덱스 파일이 서치키에 따라 연속적인 순서로 저장되어있는데(clustering index) 파일을 찾는데 주로 프라이머리 인덱스가 사용되는데,서치키가 꼭 프라이머리 키일 필요는없음
- 세컨더리  인덱스 파일의 순차적인 순서와 별개로 서치키가 구성되는 인덱스(nonclustering index)

- 인덱스-시퀀셜 파일 서치키가 프라이머리 인덱스를 갖는 파일 서치키에 의해 해당파일이 순차적으로 저장되어있다.

9)
Dense index file 파일내에 모든 서치키의 값이 인덱스 엔트리에 들어가있는 경우
서치키를 ID로 했다고하면,
인덱스 엔트리에는 모든 ID가 있는 경우

-> 각각의 ID마다 포인터를 가지고 있기때문에 원하는 값을 바로바로 찾을 수 있고, 어세스 타임이 빠르겠지만 그만큼 공간이 커지겠다.

인덱스 엔트리가 ID에 의해서 정렬되어있고, 파일도 마찬가지인 모습을 볼 수 있다

10)
아이디가 아니라 dept_name으로 정렬한 예시
인덱스 엔트리와 파일 모두 dept_name으로 정렬되어있다.

같은 값에 대해 여러개의 레코드가 존재할 떄 포인터는 가장 첫번째 레코드를 가르키게 된다

11)
Sparse Index Files
몇개의 서치키만 인덱스 엔트리에 넣는 경우
역시나 순차적으로 저장되어있는 경우에만 고려가능

K라는 값을 찾고 싶으면, K보다 작지만 가장 큰 서치키를 비교하며 찾고
그 위치에 포인터로 접근한다음에 연속적으로 이동하며 원하는 레코드를 찾는다

예)
22222를 찾는다
이거 보다 작은 값중에 가장 큰값은? -> 10101
10101이 가르키는 레코드로 간후, 22222가 나올 때까지 연속적으로 이동하며 찾는다

12)
덴스 인덱스와 스파스 인덱스 비교

스파스 인덱스
공간상의 비용이 낮다
삽입, 삭제시 훨씬 적은 오버헤드 발생
-> 스페이스 오버헤드 줄고, 어세스타임이 늘어났다

덴스 인덱스
해당 레코드를 찾아가는데 걸리는 시간이 짧다(어세스 타임이 짧다)
-> 스페이스 오버헤드 늘고, 어세스타임이 짧아졌다

=> 트레이드 오프 관계(스페이스오버헤드 - 어세스 타임)
이 관계를 잘 고려해야한다

절충안으로 나온것
결국에는 스파스 인덱스를 써야하는데, 일반적인 스파스 인덱스가 아니라
블록당 하나의 인덱스를 갖는 스파스 인덱스를 써야한다.
데이터는 블록단위로 전송이 되기때문에, 블록을 가르키는 인덱스를 갖는 스파스 인덱스를 사용한다.
레코드에 어세스하는 타임은 최소화 시키면서 인덱스의 크기도 좀 줄이는 방향
트레이드 오프 관계를 좀 절충한 방향이겠다. 덴스와 스파스를 혼합했다고 볼 수 있다

13)
세컨더리 인덱스

인덱스 엔트리가 버켓을 가르키고, 버켓은 해쉬함수에 의해 특정한 위치를 가르키게 됨.
그 가리키는 위치를 통해 레코드를 가르키게 됨

인덱스 엔트리의 정렬과 파일내의 정렬이 다르다.
그래서 인덱스 엔트리와 파일내의 정렬이 다를때, 세컨더리 인덱스를 쓰는것도 효율적일 수 있겠다.

세컨더리 인덱스의경우는 무조건 덴스 인덱스여야함
연속적이지 않기때문에 특정한 위치를 찾아갈 수 없음

14)
프라이머리 인덱스, 세컨더리 인덱스

세컨더리 인덱스를 사용하는 경우
서치키로 정렬이 되어있는 상태에서, 서치키에 해당하는 부분이 파일에서는 정렬이 안되어있을 때
데이터베이스가 수정될때 인덱스를 수정하는데 오버헤드가 발생하게 된다.
왜나하면 파일내에 레코드가 삽입/삭제 될 때 마다 모든 인덱스가 업데이트되야하므로(dense이기 때문에)

시퀀셜 스캔을 할 때는 프라이머리 인덱스를 사용하는게 더 효율적이겠다

15)
멀티레벨 인덱스

인덱스의 크기가 커지면 공간상의 오버헤드가 발생할 수 있다.
그 경우의 연장선상이라고 생각하면된다.
인덱스가 너무커서 메모리에 하나의 인덱스를 바로 적재할 수 없는 경우가 발생할 수 있는데,
그렇게 되면 인덱스가 2개의 블록으로 나누어져서 어세스하는데 비용이 증가하기때문에
인덱스를 쪼개서 사용하는 방법
2개 이상의 레벨을 갖는 인덱스 구조
인덱스를 위한 인덱스를 만들어 주는 구조

한 번에 적재하지 못하는 큰 인덱스 -> 이너 인덱스
이너 인덱스를 그냥 사용하는게 아니라 블록단위로 쪼개서 사용
그러한 블록단위의 이너 인덱스를 가르키는것 -> 아우터 인덱스

공간상의 문제는 해결할 수 있지만 디스크에 접근하는 횟수는 증가할 수 있으므로 이러한 점을 고려한다

이렇게 쪼갰는데 또 크다
-> 아우터 인덱스를 또 쪼개서 레벨을 올리면됨

16)
멀티레벨인덱스 예시

17)
파일상의 업데이트가 발생했을 때 어떻게 인덱스에 반영되는지
삭제경우
멀티레벨은 고려 안함

싱글레벨 인덱스
- 덴스 인덱스 먄약 삭제되는 레코드가 특정 서치키가 가르키는 유일한 값인경우, 인덱스 엔트리의 서치키도 삭제하면 된다. 유일하지 않은 경우면, 인덱스 레코드가 다음 레코드를 가르키게 한다. (dept_name의 경우, 컴퓨터공학 레코드가 여러개있는데, 1번째 레코드가 삭제된다면, 서치키의 포인터는 그 다음 레코드를 가리켜야겠다)
- 스파스 인덱스 서치키에 대한 엔트리가 인덱스에 이미 존재하는 경우에는 인덱스의 엔트리를 파일상의 다음에 존재하는 서치키 값으로 대체. 다음 서치키 값도 인덱스 엔트리에 존재한다면, (?) ex) 다음쪽 예제 15151 레코드 삭제 -> 인덱스 엔트리 영향 X, 업데이트할 필요 없음  32343 레코드 삭제 -> 포인터의 위치를 다음레코드인 33456으로 옮기고 서치키 값도 수정  근데 만약에, 33456이 인덱스트리에 이미 존재했다면, 인덱스 엔트리는 따로 업데이트 필요없이 파일 엔트리만 삭제한다

18)
삽입의 경우
삽입될 레코드의 위치를 먼저 찾아야하고,
그 이후 덴스 vs 스파스 비교

- 덴스 삽입될위치에 삽입해서 업데이트 시켜주면된다. 정렬된 상태는 꼭 유지시켜줘야한다 만약 인덱스 엔트리가 블록크기에 대해 꽉찼었는데, 거기에 또 삽입이되면 새로운 인덱스를 위한 블록을 만들어줘야하는 문제 발생 -> overflow block
- 스파스 삽입이되도 인덱스에 대한 업데이트를 굳이 해줄필요 없다. 블록이 오버플로우가 되면 필요하겠지만.

19)

21)
B+ 트리 인덱스 파일구조
14단원의 거의 대부분 내용임

22)
기존의 봤던 인덱스 시퀀셜 파일의 문제점
- 파일이 커지면 커질수록 오버플로우 블록이 발생할 확률이 커진다 -> 그만큼 디스크와 접근하는 횟수늘어남 -> 성능 떨어짐
- 이를 방지하기위해 인덱스파일을 재구성해야하는데, 오버플로우 블록이 발생할때마다 재구성하면 이것도 비용발생

이러한 단점을 해결하기 위해 나오는 B+트리 인덱스파일
효율적이기 때문에 이걸 일반적으로 사용
- 삽입, 삭제가 일어났을때 인덱스파일 업데이트 비용이 매우 적게든다.
- 인덱스 파일을 재구성하는 비용이 아예 들지않음

단점
삽입, 삭제 연산하는 데 비용
추가적인 공간이 들 수 있음

그러나 장점이 워낙좋아서 단점을 단점이라고 하기가 뭐하다.

23)
B+트리의 형태

B+트리 특징
- 루트부터 리프까지 가는 길이가 모두 같다 -> Balanced tree
- 루프나 리프가 아닌 중간에 존재하는 모든 노드들은 n/2의 올림한 수부터 n까지의 자식을 가진다
- 리프노드는 (n-1)/2 ….

B+트리는
좌우가 대칭이고 높낮이가 다 같다

루트가 리프가 아니면 -> 최소 2개의 자식노드를 가져야함
루트가 리프 -> 루트 자체가 0부터 n-1 사이의 값을 갖는다

-> 이부분 잘 찾아서 다시 곹부. 중요함 ⭐️

24)
포인터가 자식노드를 가르키고, 리프노드는 파일의 레코드를 가르킨다

…다시 읽어보기 …

25)
리프노드의경우
실제 코드의 값을 가르켜야함

…다시 읽어보기 …

26)
리프노드가 아닌 경우
멀티레벨 스파스 인덱스 형태를  띤다.

n개의 포인터가 있다고 가정,

…다시 읽어보기…

27)
n=6일때 예제
서치키는 name으로 했을때

…다시읽

28)
n=4일 때의 예제

29)
앞 내용의 연장선상

노드의 연결은 포인터로 되어있는데, 논리적으로의  포인터의 끝이 물리적의 끝과 같지는 않다.

….다시읽

30)
V라는 값을 찾기 위한 수도코드.

수도코드는 간단하게만 설명.

31)
B+트리의 검색의 효율성 정리

K개의 서치키가 있을때, 트리의 높이는 log(n/2올림) (K)

……..다시읽

노드에 많이 접근하면 접근할 수록 디스크에 접근하는 횟수가 증가하는거기 때문에 효율이 낮아진다.
-> 레벨이 작을수록 디스크에 접근 가능성을 줄여주기 때문에 훨씬 빠른 검색가능

