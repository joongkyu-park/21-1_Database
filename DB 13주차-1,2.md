# DB 13주차-1,2

21)
⭐️RAID. 이 단원에서 유일하게 중요함
데이터를 중복 또는 병렬적으로 저장하는 구조
-> 리드 라이트를 병렬적으로 가능하게함

데이터를 중복저장해서
디스크가 고장나도 복구할 수 있기 때문에 데이터 신뢰성을 높여준다

다수의 디스크를 하나의 디스크처럼 보이게 하는 디스크 구조.

high capacity, high speed : 병렬처리를 통해 저장성능을 높이고
high reliability : 데이터를 중복저장 -> 특정한 디스크고장, 다른 디스크를 통해 복구 -> 신뢰성 높임

병렬처리와 중복저장이 RAID의 핵심

22)
중복을 통해 데이터의 신뢰성을 향상시킨다.

여기서의 중복.
디스크가 고장이나서 정보의 손실이 발생할 수 있는데,
그 고장이 났을 때 다시 데이터를 불러올 수 있도록.
모든 디스크에 데이터를 복사해서 저장하는 것
-> Mirroring(or shadowing)

2개의 디스크(하나의 디스크처럼 보이지만)
원본
원본에 대한 복사본

write -> 두 개에 다 write해야함
read -> 둘 중에 하나만 read

하나가 고장이나면 살아있는 다른 디스크를 통해 기존에 고장난 디스크 복구

두 개의 디스크가 고장나버리면 복구할 수 없겠지만..

밑에있는 내용은 모르셔도 될거같아요~

23)
병렬처리를 통해 성능을 높이자.

디스크에서 병렬처리를 하는 2가지이유
- 작은 양의 데이터처리는 다수의 디스크에 로드를 분산해서 처리율을 증가시킨다
- 큰 양의 데이터처리는 큰 블록자체를 병렬처리해서 response time을 줄인다.

다수의 디스크를 통해 데이터를 분산해서 처리하게되면,
데이터를 처리하거나 전송하거나 할 때 성능이 향상. 전송속도가 향상

2가지 방법이 있다.
비트레벨 스트리핑
각각의 디스크에 비트를 저장.
예시) 1바이트는 8비트이니까 8개의 디스크에 나눠서 저장. 1번째 비트는 1번째 디스크에. 이런식으로.
하나의 디스크를 사용하는거 보다 read는 8배 빠른 속도.
대신에 seek타임, 즉 위치를 찾는경우 싱글디스크보다 더 오래걸릴 수 있다. 8개로 분산된 곳을 다 찾아야하기 때문.
최근에 실제로는 잘 사용안된다. 블럭레벨 스트리핑을 사용

블럭레벨 스트리핑
블럭, 하나의 데이터의 집합 정도로 생각.
블락단위로 데이터를 여러 디스크에 저장
n개 디스크, i개 블록이 있을 때 (i mod n) +1 디스크에 저장

작은 양의 데이터처리는 다수의 디스크에 로드를 분산해서 처리율을 증가시킨다
큰 양의 데이터처리는 큰 블록자체를 병렬처리해서 response time을 줄인다.

24)
redundancy tradedoff: 최소 2배이상의 디스크가 필요하게 때문에 코스트가 올라간다
병렬처리 tradedoff: 신뢰성을 높이지는 못한다.

RAID 레벨
레이드 레벨에 따라서 

패리티 비트 사용 -> 레이드 1처럼 일대일 매칭이 아니라 -> 로우 코스트 가능

레이드 레벨 0
redundancy도 없다.
블록단위의 분산된 디스크이기 하지만.
데이터의 신뢰성이 매우 낮겠다.
데이터가 손실되는게 중요하지않고, 빠르게 처리가 필요한 어플리케이션에서 사용

레이드 레벨 1
레이드 레벨 0을 개선
기본적으로 블록단위의 분산 디스크 형식
각각의 디스크에 대한 mirrored 디스크 존재
하나의 디스크가 고장이 나도, mirrored 디스크를 통해 복구 가능 -> 어느정도 신뢰성 확보가능
로그파일을 저장하는 어플리케이션에서 많이 사용. 

25)
레이드 레벨5, 6은 partity 블록을 통해서 디스크의 내용을 저장한다.
사용하면 좋은점.
기존의 5개의 디스크가 있으면 5개의 추가적인 미러드 디스크가 필요했었다.
partity 블록을 사용하면, 4개의 디스크가 있을 때 1개의 디스크만 있어도 가능.
-> 중복때문에 발생하는 비용 최소화 가능

xor 연산을 통해서 다른 디스크에 있는 내용을 복구가능. 자세한건 다루지 않음.

패리티 블록 : 나머지 디스크의 블록들의 내용을 중복 저장하여 복구가 가능하다.
패리티 블록에 j번째 블록에 나머지 디스크들의 j번째 블록의 xor값이 저장된다.
특정 디스크에 블록 j에 다른 데이터가 write 되었을때, 패리티 블록도 다시 계산되어야함
2가지 방식 존재
-과거의 값과 새로의 값을 다 고려해서 새로운 패리티 블럭의 값을 저장하는 방식. (과거의 기록까지 고려를 하는) -> 두번의 리드, 두번의 라이트 필요. -> 2번의 리드, 2번의 라이트가 좀 비효율적
-기존의 값을들 고려하지않고 새로운 값과 새로운 패리티 블록의 값만 고려하는 방식. -> 두번의 라이트만 해서 보다 효율적

26)
레이드 레벨 5
패리티 블록을 저장하는 디스크가 따로 존재하는게 아니라, 각각의 디스크의 원본데이터와 패리티 데이터를 각각 다 저장하고 있는 방식
원본데이터도 저장하고, 다른 디스크를 복구할 수 있는 패리티도 저장.

만약의 디스크가 5개인 경우, N번째 패리티 블록은 (N mod 5)+1 번째 디스크에 저장.
![DB 13주차-1,2](images/DB%2013주차-1,2.png)

이러하게.

문제점
두개의 디스크가 한번에 고장 났다 -> 복구할 수 없을 수 있다.

27)
레이드 레벨 6
P와 Q라고 하는 패리티블록을 가진다.
두 개의 디스크가 한번에 고장나도, 복구가 가능하도로 개선
-> 레이드 레벨 5에 비해 데이터 신뢰성이 높아진다.
대신에 패리티블록을 2개 저장해야하니까 코스트가 더 크겠다.
그러나 최근에는 데이터 신뢰성이 더 중요하니까 레이드 레벨 6을 자주 쓴다.

자세한 저장방법등은 안배운다.
중복저장, 병렬처리의 의미와
각각 레벨이 어떤차이 있는지.
그거만 하면된다

28)
앞에서 배운 레이드를 바탕으로, 어떤 것을 사용해야할지

비용을 비교, 고려
성능을 비교, 고려
	한번에 전송을 얼마나 할수있는지(입출력)
	디스크가 고장이 났을 때의 성능. 복구할때 걸리는 성능

레이드 레벨 0
병렬처리는 되었지만 중복처리는 되어있지않다.
-> 데이터복구가 사실상 일어나지 않음. 데이터의 보안성이 중요하지 않은 경우에 사용

29)
레이드 레벨 1과 레벨 5가 일반적으로 사용된다

레이드 레벨 6
비싸지만 데이터 보안, 신뢰성을 많이 보장한다.
신뢰성이나 데이터의 안전이 매우 중요한 경우 사용

레이드 레벨 1 ,레이드 레벨 5
write 성능 : 레벨 1 > 레벨 5 -> 두번의 write만 하면 되니까. 레벨 5같은경우는 기존의 패리티 블록과 기존의 원본데이터에 접근해야하서 2번의 리드가 추가적으로 필요하기때문.
=> write가 많이 일어나는 시스템(주기적으로 데이터가 갱신되는 경우) : 레벨 1이 더 좋다.
저장비용 : 레벨 5 > 레벨 1 (레벨 5가 더 저렴)
대용량의 데이터를 저장하는 경우처럼 리드가 많고 write가 거의 일어나지 않는경우 : 레벨 5 > 레벨 1
소규모의 데이터를 계속 저장하는 경우. 로그같은(카톡 등 ) : 레벨 1 > 레벨 5

30)
하드웨어적인 이슈

소프트웨어 RAID
하드웨어가 추가적으로 들어가는게아니라, 소프트웨어를 통해서 RAID 계층을 구현.

하드웨어 RAID
RAID 구축 시 추가적인 하드웨어가 들어가는 경우
…

31)
Latent failure
기존에는 write가 제대로 일어나다가, 추후에 손상이 된다고하면
일찍 발견하면 다른 mirrored 디스크나 패리티블록을 통해 복구할 수 있는데,
늦게 발견하면 전체적인 데이터 손실이 크게 발생할 수 있다.

Data scrubbing
위와 같은 상황을 막기 위해서 주기적으로 손상된 부분이 있는지 스캔하는 작업

How swapping
전기를 끄지않고 결함이 있는 디스크를 제거하고 새로운 것으로 대체하는 방법. 추가적인 하드웨어를 필요로함.
전원을 끄지않고 새로운 것을 교체할 수 있으니까 복구에 걸리는 시간 단축
시스템의 availability 엄청나게 상승
availability : 시스템을 고장이나 장애없이 계속해서 정상적으로 사용하게 해주는 능력
2가지 방법이 있다
- 항상 온라인 상태, 즉 유지되고 있는 spare한 disk가 있으면 된다.
데이터 복구속도가 엄청나게 빠르겠다.
- 시스템의 기능을 멈추거나 고장나게 하는 가능성을 아예 줄여버림. 아래의 방법을 사용해서.
	- 정전이 날 경우를 대비해 백업 전력공급원을 가지고 있는다.
	서버실 같은경우는 정전이 나도 꺼지지 않는다. 백업 전력공급원이 있기 때문. 구글은 구글댐도 따로 있대.
	- 다수의 컨트롤러나 네트워크 장치를 통해 시스템이 고장이 나게 되면 다른 시스템을 통해 바로 복구할 수 있도록

뒤쪽의 disk block access는 안함.
끝.

이 단원에서 꼭 외워야할 것⭐️
- 레이드의 중복, 병렬처리가 왜 필요한지 2가지 구분할 수 있어야함
- 각각의 레벨의 특징과 차이점

⭐️
이번 시험에는 
6, 7단원에서 응용 문제가 많이 나오겠다.
나머지는 거의 개념이라 그냥 개념적인 측면만 학습.

Ch 13. Data Storage Structures

데이터가 어떻게 저장되어있는지. 데이터 저장 구조. 데이터에 어떻게 접근하는지

2)
목표

3)
개요

4)
File Organization
파일의 구조

5)
DB는 여러개의 파일의 집합형태로 저장되어있다. 파일은 디스크에 영구적으로 저장.
파일은 record로 구성되어있고
record는 field로 구성되어있다.

![DB 13주차-1,2-1](images/DB%2013주차-1,2-1.png)

릴레이션에 비유하면,
전체적인 도메인 - 파일
각각의 튜플 - 레코드
각각의 컬럼 - 필드

파일이 한꺼번에 저장이 되는게아니라, 블록단위로 저장된다.
블록은 고정된 길이의 저장 단위. 저장매체에 할당되는 단위.
데이터의 전송단위 또한 블록.
블록은 다수의 레코드를 포함하는 구조이겠다

파일에서 레코드가 어떻게 구성되는지 알아보기 위한 가정.
- 레코드의 크기가 고정된 경우만 생각
- 각각의 파일에서는 특정한 타입의 레코드만을 저장
- 각각의 파일은 각각의 릴레이션에서만 사용된다.
- 레코드는 블록보다 크기가 커서는 안된다

6)
레코드의 크기가 고정된 경우 어떻게 저장이 되는지

간단하게 생각.
i번째 레코드가 어디에 저장되냐
각각의 레코드의 크기가 n일 때, n * (i-1)번째 바이트부터 저장되겠다
ex) 10바이트씩 레코드 저장
0번째 레코드 : 0바이트부터 10바이트 저장
1번째 레코드 : 10바이트부터 20바이트 까지 저장
…

주의해야할점
다수의 레코드가 블록의 크기를 넘어가는경우.
블록의 크기가 500바이트인데, 하나의 레코드가 53바이트.
10개의 레코드가 1개의 블록에 딱 들어갈 수 없다. 3바이트 짤리니까
-> 레코드가 블록의 경계를 넘게 하지 않게해야한다. 그냥 9개 레코드만 저장하고 나머지 공간은 비워두는게 낫다는 뜻

레코드가 블록의 경계를 넘게 하지 말아야하고, 비는 공간도 최소화 시켜야 할 것.

7)
특정 레코드가 지워졌을 때 어떻게 관리를 해야하는지

3번째 레코드가 지워졌다고 가정

3가지 방법 존재.

1. 지워진 이후의 레코드를 한칸씩 앞으로 땅긴다.
레코드의 이동이 너무 많이 발생되는 단점.
다수의 레코드가 지워지면 이동이 많아지므로 비효율적이겠다

8) 2.
지워진 부분에 마지막 레코드를 집어넣는다.
한번의 이동만으로 지워진 부분을 다른 레코드로 대체가능

그러나 현재 id가 순차적으로 저장되어있는데, 이 순서를 깨버리는 문제가 발생

9)
3.
linked list형태를 사용해서 삽입과 삭제 관리.
포인터를 통해서 삭제된 위치들을 가르킨다.
포인터들의 정보는의 헤더에 저장하고, 헤더를 위한 추가적인 공간필요.

기존의 배열형태로 관리한거보다 훨씬 효율적으로 관리가 가능하다.

10)
이번엔 크기가 가변적인 레코드

크기가 가변적인 레코드가 필요한 경우
- 하나의 파일에 다양한 레코드 타입이 존재하는 경우
- varchar와 같이 가변길이를 허용하는 변수가 필요로 할 때
- repeating field(배열과 같은 필드)가 필요할 때

가변길이 어트리뷰트의 표현
- 고정길이를 가진 어트리뷰트를 앞에 넣어주고, 가변길이 어트리뷰트를 뒤쪽으로
- variable length attribute를 가르키는 부분은 offset과 length를 이용하여 표현 	offset : 해당 데이터가 시작하는 부분을 의미
	length : 해당 레코드의 크기
	ex) 21, 5 -> 해당 어트리부트 21부터 시작하고 크기는 5이다.
- 널값은 비트맵을 통해 널밸류 표현 	ex) 12-19까지 salary를 나타내는 어트리뷰트인데,
	20의 널비트맵이 0000 -> salary에 일반값이 있는거고
	널비트맵이 0001 -> salary가 널값임을 의미

11)
variable-length 레코드를 블록에 저장하기 위한 방법을 알아보자.
이를 위해 사용되는 개념. Slotted page를 이용.
Slotted page를 통해서 다수의 variable-length 레코드를 저장할 수 있다.

Slotted page 헤더에는
- 레코드 엔트리의 개수(레코드의 개수)
- 블록상의 빈 공간의 마지막 부분을 가르키는 포인터. 	free space는 여분의 공간.
- 각 레코드의 위치와 크기
	각 엔트리는 포인터를 통해서 해당 부분의 variable-length 레코드가 어떻게 저장되어있는지 가르키는 포인터를 포함

이런 구조를 통해 레코드는 페이지 내에서 업데이트 및 삭제가 일어나도, 계속해서 이동하면서 빈공간이 없이 연속적으로 유지.

이를 위해서 헤더내의 엔트리가 계속 업데이트 되야하고, 포인터도 계속 가르키는 위치를 바꾸어주면 빈공간없이 variable-length 레코드를 블록상에 저장할 수 있게끔 만들 수 있다.

포인터는 레코드를 직접적으로 가르키지 않아야하고, 엔트리를 가르키게하고, 엔트리가 해당 부분의 레코드를 가르키게 끔 해야하는데(즉 offset과 length를 통해 간접적으로 가르키게 해야함)
이유는 블록 공간의 효율성을 위해서.
레코드가 이어져서 저장이 되어야하는데, 이어져서 저장되는 것이 아니라 쪼개져서 저장되는 것을 단편화라고 한다. 그러한 레코드가 단편화되는 것을 방지한다.

12)
파일 내의 레코드가 어떻게 구성되는가

13)
레코드의 집합을 파일내에서 어떻게 구성하나

- 힙구조 파일내의 레코드를 위한 공간만 있으면 레코드를 순서에 상관없이 어디에다 임의로 놓을 수 있는 구조를 말한다
- 시퀀셜 구조 서치키라고하는 값에 의해서 각각의 레코드들을 연속적인 순서로 저장
- Multitable clustering file organization 서로 다른 릴레이션을 유사한 어트리뷰트 끼리 묶어서 같은 파일 내에 저장 (뒤에서 배우겠지만 조언연산을 최적화하기 위한 방법)
- B+트리
- 해싱

이 2개는 다음주에 자세하게 다룬다.

14)
힙 파일 오가니제이션
파일 내에 빈공간 내에 아무곳이나 레코드를 위치시킬 수 있음.
설명 생략

15)
Sequential file organization

전체 파일을 순차적으로 처리해야하는 어플리케이션에 적합
search-key를 통해 파일 내의 레코드를 정렬 시킨다.

교재에서는 id를 기준으로 정렬을 했고, 서치키 순서대로 레코드들을 포인터로 연결했다

16)
삭제시 - 링크드리스트 삭제하는것처럼 포인터의 위치만 변경
삽입 시
- 삽입할 위치를 찾는다 - 빈공간 있으면, 그 곳에 그냥 삽입하고 포인터만 재배치 - 빈공간이 없으면, overflow block에 삽입. overflow block이란 동일한 블록이 아닌 다른 블록상에 레코드를 위치시켜야함. => 두가지 케이스 모두 포인터를 통해서 잘 연결해줘야함

이렇게 순차적인 순서를 계속 유지하려면, 서치키를 기준으로 파일을 수시로 재구성해주어야한다.
-> 비용이 많이드는 단점이 있다.

17)
Multitable clustering file organization

하나의 블록에 다수의 릴레이션 저장하는 방식

동일한 어트리뷰트를 기준으로 저장하게된다. 조인연산을 생각하면됨.

18)
장점
조인연산을 효율적으로 수행가능

단점
하나의 릴레이션을 위한 쿼리처리를 할 때

블록내의 레코드의 크기는 릴레이션에 따라 달라지기때문에 고려해야함.

특정 릴레이션의 기록의 연속성을 파악하기 위해 포인터를 통해 연결해줘야함
![DB 13주차-1,2-2](images/DB%2013주차-1,2-2.png)

ex) department 릴레이션의 경우, 이런식 왼쪽처럼 연결해줘야 department relation의 구성을 알 수 있겠다.

19)
Data-Dictionary Storage

20)
데이터를 저장을 할 때는 릴레이션과 관련된 정보도 저장해야한다.
그러한 릴레이션과 관련된 정보 -> 메타데이터

메타데이터의 예
음원파일 -> 파일명, 파일크기, ….

이런 메타데이터를 저장하는 공간이 data-dictionary

data-dictionary에서는 릴레이션과 관련된 정보를 저장.
- 릴레이션 이름, 어트리뷰트의 타입, 이름, 길이 등, 뷰에 대해서도, key나 FD같은 integrity constraints 등
- 사용자 관련 정보, 아이디, 패스워드 등
- 릴레이션과 관련된 정적이고 설명가능한 정보 ex)릴레이션의 튜플의 갯수
- 저장위치
- 인덱스와 관련된 정보

21)
data-dictionary도 마찬가지로 릴레이션 형태로 저장

릴레이션에 접근하려면, 릴레이션 메타데이터에 접근해야함

효율적인 접근을 위해서 메타데이터 딕셔너리는 릴레이션이 정규화 형태가 아닐 수 있고,
In-memory(코드내에 저장해서 빠르게 접근가능한 형태)로 저장된다.

22)
Database Butter
메인메모리상의 DB를 위한 블록을 저장하는 공간

23)
블록은 데이터 저장단위이자 전송단위

데이터베이스 시스템은 디스크와 메모리사이의 블록전송을 최소화해야함
디스크와 메모리의 속도차이가 있기때문
-> 메인메모리 상에 최대한 많은 블록을 유지시켜야함
그러나 현실적으로 모든 블록을 올릴 수 없기 때문에,
블록의 복사본을 저장하는 메인메모리 상의 공간인 ‘버퍼’라는 곳을 둬서, 자주 쓰이는것은 빠르게 처리하도록함

캐쉬매모리나, 버츄얼메모리와 유사하다고 보면됨

버퍼매니저 - 버퍼공간을 관리

24)
버퍼 매니저에서 하는일

디스크 상의 블록을 불러올때 가장 먼저 호출하는 것은 버퍼 매니저.
해당 블록이 버퍼에 존재하면 메인메모리상의 블록주소를 호출해서 빠르게 처리,
만약에 버퍼에 해당블록이 없다면 블록을 위한 공간을 버퍼에 할당.
새 블록을 위해 기존의 블록을 버리고 해당 위치에 배치를 시킴
만약에 교체되는 블록이 디스크에 쓰여진 가장 최근 블록과 비교해서 변경된게 있으면 다시 디스크에 저장.
그 후 버퍼관리자는 디스크로부터 요구된 블록을 버퍼에 읽어와서, 메인메모리에서 블록주소를 사용자에게 전달.

25)
버퍼할당을 위한 정책들

대표적인 전략 LRU(least recently used)
최근 가장 적게 참조된 블록을 버퍼에 버리고, 변경된 사항이 있으면 디스크에 다시 저장
과거의 블록사용패턴을 통해 미래의 사용패턴을 예측하는 것

안좋은 경우.
다음과 같은 예제
![DB 13주차-1,2-3](images/DB%2013주차-1,2-3.png)

 r의 튜플 1개에 대해 s의 모든 튜플을 살펴볼때,
가장 최근에 참조된 s의 튜플은 -> 안쓰일꺼고
참조되지 않은 s의 튜플은 -> 쓰일확률이 높다

=> LRU와 반대되는 상황.

이러한 상황에서는 MRU를 써야하겠다

26)
다른 기법들

Toss-immediate
마지막 튜플에 대한 블록처리가 완료되면, 해당 릴레이션에 대한 더이상의 처리가 필요가 없어지므로 해당 릴레이션에 대한 블록공간을 제거해버리는 방법

MRU
가장 최근에 참조된 블록을 교체하는 방법

버퍼매니저는 어떤 쿼리가 어떤 릴레이션을 참조할 것인지 가능성에 대한 통계정보도 사용
예를 들어 데이터-딕셔너리와 같은 경우는 자주 접근된다. 따라서 데이터-딕셔너리같은경우는 메인메모리 버퍼에 유지시키는게 유리하다.

27)
Column-Oriented Storage
지금까지 배웠던 릴레이션은 row-Oriented Storage 라고 생각하면된다. 튜플중심

28)
컬럼기반 저장기법.
데이터를 튜플단위로 저장하는게 아닌, 어트리뷰트 단위로 저장
주로 빅데이터 처리를 위해 많이 사용되는 방식

29)
장점
- 특정 어트리뷰트에 접근할때 I/O 연산감소
- CPU 캐쉬성능, 압축성능 좋음
- 최신cpu의 벡터연산에 유리함

-> 빅데이터를 처리하는 저장소에서 많이 사용

단점
- 튜플과 관련된 연산시 비용증가

