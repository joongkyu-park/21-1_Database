# DB 6주차-2

ch4. intermediate sql (2)

4.2)
intermediate sql 의 나머지 부분

4.3)
Transactions
트랜잭션
크게 2가지를 만족시켜야한다.
- consistency, atomicity 정확하고 일관성이 있어야한다.
- cocurrency를 유지시켜야한다. 동시접근이 가능하도록 계속 업데이트 시켜야한다.

4.5)
트랜잭션.
특정한 쿼리나 업데이트문으로 구성되어있음.
일종의 work(작업)의 단위라고 생각하면 됨

sql이 실행되는거 자체가 트랜잭션의 시작이라고 볼 수 있다.

커밋, 롤백 이라는 2가지 트랜잭션의 종류

- 커밋 워크 업데이트되면 영구적으로 정보가 데이터베이스에 유지되어야한다.
- 롤백 워크 업데이트하다 중간에 오류가나면, 그동안 수행되었던 내용 전부를 취소시킨다.

트랜잭션엔 아토믹한 특징이있다.
커밋, 롤백이라는 작업을 통해 atomicity를 유지한다.
전부 수행을 시키거나, 오류가 발생하면 전부 취소시키는게 atomicity의 특성. -> all or none.

concurrency 유지해야한다.
동시에 똑같은 db를 업데이트 시킨다고 하면 atomicity가 유지되지 않을 수 있다.
예를들어 한명이 접근해서 업데이트 시키려고 한다면 다른 사람들의 접근은 막던지 이런식으로

4.6)
integrity constraints
무결성 제약조건
일관성을 유지하기 위한 방법

4.7)
이게 필요한 이유
-데이터베이스 관리자가 데이터베이스를 변경할때, 실수로 db가 손상이 되는것을 방지
-데이터의 일관성을 유지하기 위해서

예시
- instructor의 name은 null이 되면 안된다
- id는 프라이머리키니까 같은게 2개이상이면 안된다.
- department r과 course r간에, course r이 dept_name이라는걸 department r에서 레퍼런스하려 foreign key로 쓰는데, course에 있는 dept_name 값은 department에도 있어야한다. 당연한 얘기..
- budget은 0보다 커야한다..

뭔가 당연한 얘기들..

4.8)
릴레이션을 생성할 때 integrity constraints

- 프라이머리키 지정
- not null
- unique
- 체크

4.9)
not null constraints

해당 어트리뷰트는 Null이 될 수 없다는 뜻.

sql은 프라이머리키에 널값허용 안함. 기본적으로 not null로 선언해줘야한다

4.10)
unique constraints
유니크안에 명시한 어트리뷰트들이 candidate키가 될 수도 있다고 명시.

캔디데이트 키는 널값을 허용
이유?
널값이 다른값과 같다고는 볼 수 없기때문에.

4.11)
Check 절
모든 튜플이 만족해야하는 조건을 명시하는 방법

예를들어
semester라고 하는 어트리뷰트는 4계절 값중 하나만 가져야한다는 조건 필요
-> 마지막줄에 check 사용

또는 budget은 무조건 0보다 커야한다, 이런것도 조건문을 넣어줄 수 있겠다.

특정 어트리뷰트가 무조건 만족해야하는 조건 명시.

4.12)
referential integrity

레퍼런싱 릴레이션 : 포린키(레퍼런스드의 프라이머리키)를 가짐 레퍼런스드 릴레이션 : 프라이머리키를 가짐

레퍼런싱에서 가지고 있는 포린키값은 레퍼런스드에 꼭 존재해야한다.

4.13)
포린키 선언할때.

4.14)
cascading action in referential integrity

기본적으로 referential integrity을 위반한것 실행하지않는데, 그걸 무시하고 진행시키고싶을때 사용

문제가 생길수있는데, 변경된사항은 따로 기록해놨다가 나중에 업데이트.

일반적으로는 잘 사용되지 않음.

cascade 대신에
set null 이나 set default라는 것을 사용가능.

4.15)
트랜잭션상황에서 integrity constraint가 위반되었을 때

여기서 mother와 father가 포린키인데,
새로운 튜플을 넣을때 mother값을 A, father값을 B라고 하고 넣고싶을때
포린키이기때문에 person안에 마더가 A인값, 파더가 B인값이 이미 있어야함. 있나 확인하고 없으면 위반.

어떻게 위반하지 않을가?
- 파더와 마더에 대한 정보를 먼저 삽입
- 파더와 마더를 일단 널값으로하고, 모든 person을 넣은다음에 업데이트
- defereed문을 사용. 이 상황에서 발생하는 constraints를 업데이트가 끝난 다음에 고려함.

4.16)
check문도 서브쿼리를 활용할 수 있다.

4.17)
assertion
좀더 강력한 조건.
데이터베이스가 항상 만족해야하는 조건을 나타냄.

4.18)
sql에서 미리 가지고 있는 빌트인 데이터타입

4.19)
- date
- time
- timestamp
- interval

4.20)
대용량의 데이터, 객체를 저장하는 방법

데이터 자체를 저장하는게 아니라 -> 데이터가 저장한 위치값을 저장함

- blob 이미지나 영화를 주로 다룸
- clob 문장 같은 데이터를 주로 다룸

4.21)
사용자가 직접 정의한 타입

create type을 통해 가능

4.22)
도메인

이전에는 create domain이란걸 사용해서 사용자 정의 타입을 만듬
차이점은 not null과 같은걸 지정할 수 있음
user-defined에서는 불가능

또한 check절을 통해 제약조건들을 추가가능

4.23)
인덱스 개념

4.24)
쿼리를 통해 어떤 데이터에 대한 정보를 찾으려고 할 때.
많은 양을 찾기보단 보통 적은 양을 찾는게 일반적임. (특정한 누구누구를 찾아라)
따라서 처음부터 끝까지 다 찾는거는 비효율적
-> 인덱스를 활용하여 모든 튜플을 다 사용하지않고도 원하는 데이터에 접근

4.25)
주로 프라이머키를 인덱스로 많이 사용

인덱스를 사용하면 다 살펴보지않고도 해당 그 위치로 바로 가는것이 장점

4.26)
사용자에게 권한부여

4.27)
데이터베이스에서 사용자에게 어떤 권한을 부여할까 지정

데이터베이스에 접근과 관련된 권한
리드 : db를 읽기는 가능한데 수정은 불가능함. 일반적인 사용자들이 가지는 권한
인서트 : 인서트는 할 수 있는데 수정은 못함
업데이트 : 수정은 가능한데 삭제는 불가능
딜리트 : 데이터 삭제 가능 

이러한 권한을 priviledge라고 이야기한다.

데이터베이스 스키마를 수정하는 권한도 존재
인덱스 : 인덱스를 생성하고 삭제하는 권한
리소스 : 새로운 릴레이션을 생성하는 권한
아터네이션 : 기존의 릴레이션에서 어트리뷰트를 추가 삭제 가능 권한
드롭 : 릴레이션을 삭제할 수 있는 권한

4.28)
어떻게 권한을 부여하냐

grant라는 명령어를 사용함.

특정 유저아이디
public은 모든 사용자에게 부여한다는 뜻
role은 나중에 배움

뷰에도 권한을 부여할 수 있는데, 뷰에 권한을 부여한다고 뷰에 관련한 릴레이션과 권한을 부여하는 것과는 다름

권한을 부여하는사람 (grantor of the privilege = database administrator)는 당연히 권한을 부여하는 권한을 가지고 있다

4.29)
sql에서 의 권한

read가 select로 바뀐거 말고는 똑같다.

all prilvildeg는 4가지 권한을 모두 부여

4.30)
권한 취소

revoke라는 명령어를 통해서 가능

권한을 두번 부여받았을때 한번만 취소하면, 그 권한이 남아 있을 수도 있음.

레퍼런싱하는 릴레이션의 권한이 사라지면 레퍼런스드 의 권한도 사라진다(?)

4.31)
role 개념
사용자한테 특정한 권한을 부여하는거보다 role을 통해 부여하는게 훨씬 좋다

역할을 정해놓고 사용자들을 매칭시켜주면된다.
사용자마다 하는게 아니라 한꺼번에 특정집단에 권한부여가능.

4.32)
롤 예시

4.33)
뷰에서의 권한

4.34)
다른 여러가지 권한

4단원 끝

integrity constraints가 어떻게 보장되는지 잘살펴보기
조인, 부분과 다르게,
정의랑 개념위주로 시험문제나옴. 예제가 많이없기때문에. 

